// <땅따먹기> 문제
// N행 4열의 크기, 각 칸에는 점수가 적혀있음
// 주의할 점 1. 같은 열을 연속해서 밟을 수는 없음
// 주의할 점 2. 마지막 행까지 내려갈 때까지 얻을 수 있는 최대 점수를 return

// 동적 계획법, 하향식 풀이
// 중복 부분 문제(=메모이제이션) : land에 최댓값을 더하며 값을 갱신, 즉 같은 값을 여러번 게산하지 않음
// 최적 부분 구조(=부분 문제 풀이) : 각 행에서 해당 열마다 최댓값을 구하는 것으로 부분 문제를 나눔

function solution(land) {
  for (let i = 1; i < land.length; i++) {
    land[i].map((_, j) => {
      // 현재 행에서 이전 행에서 가장 큰 값을 더해줌
      // j : 0, 1, 2, 3
      // 현재 행을 제외한 다른 행들 중에서만 확인하는 방법 +1, +2, +3을 해주고 % 4를 해준다.

      land[i][j] += Math.max(
        land[i - 1][(j + 1) % 4],
        land[i - 1][(j + 2) % 4],
        land[i - 1][(j + 3) % 4]
      )
    })
  }
  return Math.max(...land[land.length - 1])
}

// prettier-ignore
solution([[1,2,3,5],[5,6,7,8],[4,3,2,1]]) // 16
