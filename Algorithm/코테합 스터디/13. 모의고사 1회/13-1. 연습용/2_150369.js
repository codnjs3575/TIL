// 일렬로 나열된 n개의 집에 택배 배달
// i번째 집은 물류창고에서 거리 i만큼 떨어져 있음
// i번째 집과 j번째 집은 거리 j-i만큼 떨어져 있음
// 최대 cap만큼 배달 가능
// 각 집마다 배달할 상자와 회수할 상자 수가 주어짐
// 물류창고에서 배달과 회수를 모두 완료하고 돌아오는 최소 거리

// tip! 먼 곳부터 배달하기
// cap만큼 배달하기 or 회수하기
// deliveries와 pickups를 역순으로 순회하면서 배달과 회수를 진행
function solution(cap, n, deliveries, pickups) {
  let distance = 0 // return: 최소 거리

  let deliveriesN = 0 // 배달할 상자들의 개수
  let pickupsN = 0 // 회수할 상자들의 개수

  for (let i = n - 1; i >= 0; i--) {
    deliveriesN += deliveries[i]
    pickupsN += pickups[i]

    while (deliveriesN > 0 || pickupsN > 0) {
      deliveriesN -= cap
      pickupsN -= cap
      distance += (i + 1) * 2
    }
  }

  return distance
}

// solution(4, 5, [1, 0, 3, 1, 2], [0, 3, 0, 4, 0]) // 16
solution(2, 7, [1, 0, 2, 0, 1, 0, 2], [0, 2, 0, 1, 0, 2, 0]) // 30
// 1. 7만큼 이동(배달) : [1, 0, 2, 0, 1, 0, 0], [0, 2, 0, 1, 0, 2, 0]
// 2. 7만큼 이동(수거) : [1, 0, 2, 0, 1, 0, 0], [0, 2, 0, 1, 0, 0, 0]
// 3. 5만큼 이동(배달) : [1, 0, 1, 0, 0, 0, 0], [0, 2, 0, 1, 0, 0, 0]
// 4. 5만큼 이동(수거) : [1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0]
// 5. 3만큼 이동(배달) : [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0]
// 6. 3만큼 이동(수거) : [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]
