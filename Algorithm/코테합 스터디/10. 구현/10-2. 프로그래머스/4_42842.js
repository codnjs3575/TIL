// 8 <= brown <= 5,000
// 1 <= yellow <= 2,000,000

function solution(brown, yellow) {
  let col = 1
  while (2 * (yellow / col) + (col + 2) * 2 !== brown) col++

  return [yellow / col + 2, col + 2]
}

console.log(solution(10, 2)) // 4,3
console.log(solution(8, 1)) // 3,3
console.log(solution(24, 24)) // 8,6

// --------------------- 귀납법 ---------------------
//  y - b : 세로 X 가로
// 01 - 08 : 3 X 3 (홀) -> 가로만!
// 02 - 10 : 3 X 4 (짝) -> 가로 | 세로 1칸 늘어남
// 03 - 12 : 3 X 5 (홀) -> 가로만!
// 04 - 12 : 4 X 4 (짝) -> 가로 | 세로 1칸 늘어남 (세로)
// 04 - 14 : 3 X 6 (짝) -> 가로 | 세로 1칸 늘어남 (가로)
// 05 - 16 : 3 X 7 (홀) -> 가로만!

// y가 (홀)인 경우
// 세로는 무조건 3, 가로는 y + 2
// 01 - 08 : 3 X 3 (홀) -> 가로만!
// 03 - 12 : 3 X 5 (홀) -> 가로만!
// 05 - 16 : 3 X 7 (홀) -> 가로만!

// y가 (짝)인 경우
// 세로가 한 칸씩 늘어남, 가로는 y/세로 + 2
// y: 24일 경우 (짝)
// b 계산법 : (y/세로) * 2 + (6 + (2 * 세로 추가 개수))
// 세로 1칸 : 3 X 26(24+2) (24/1세로 = 24) 이때 b는 (24x2) + 6 = 54
// 세로 2칸 : 4 X 14(12+2) (24/2세로 = 12) b, (12x2) + 6+2(세로 1칸) = 32
// 세로 3칸 : 5 X 10(8+2) (24/3세로 = 8) b, (8x2) + 6+2+2(세로 2칸) = 26
// 세로 4칸 : 6 X 8(6+2) (24/4세로 = 6) b, (6x2) + 6+2+2+2(세로 3킨) = 24

// b 구하는 방법
// 1. (반복문) 하나씩 대입하면서 b가 계산한 것과 같은지 확인 -> 같다면 세로/가로 구할 수 있음
// 2. (계산형) b를 직접 계산하면서 가로를 구하기 (시간복잡도 1) -> 근데 계산법을 못 찾음..
