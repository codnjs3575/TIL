// 어떤 숫자에서 K개의 수를 제거했을 떄 얻을 수 있는 가장 큰 숫자
// 1924 -> 수 2개를 제거하면 [19, 12, 14, 92, 94, 24]
// number는 2자리 이상, 1,000,000자리 이하

// 로직 후보 1. 정렬 후 큰 숫자만 추출 (단순 구현)
// 1. 숫자 정렬 후 가장 큰 숫자 k만큼 추출하여 MaxNums
// 2. 입력된 값에서 MaxNums에 해당하는 숫자가 있다면 저장
// 문제점) 775841 처럼 낮은 숫자가 뒤에 오는 경우에 부적합

// 로직 후보 2. 포함이 되는 경우, 되지 않는 경우 dfs 해볼까? (dfs)
// 문제점) 1,000,000자리 이하 숫자 -> 시간/메모리 둘 다 불가능

// 로직 후보 3. 일단 저장해놓고, 새로운 숫자가 더 크다면 이전 숫자 제거 (그리디)
// [1924]) 1 저장 -> 9 저장 -> [2] 19 < 92 큼 (92 저장) -> [4] 92 < 94 큼 (94 저장)
// [9124]) 9 저장 -> 1 저장 -> [2]

// n(10) - k(4) = 6개
// [4177252841])
// 417725 -> [2]
// 417725 -> [5]
// 417725 -> [2]
// 417725 -> [8]
// 417728 -> [4]

// 가장 맨 앞, 가장 맨 뒤 숫자만 제거할 수 있음.

function solution(number, k) {
  const n = number.split('').length
  const answer = []
  let maxNum = ''

  number.split('').map((num) => {
    if (answer.length < n - k) {
      answer.push(num)
      maxNum += num
      return
    }
    // 비교 후 큰 수로 저장
    answer.slice(1) //
    console.log(num)
  })

  console.log(answer, maxNum)
}

solution('1924', 2) // 94
// solution('1231234', 3) // 3234
// console.log(solution('4177252841', 4)) // 775841
